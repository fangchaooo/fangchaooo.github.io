{"meta":{"title":"求索之路","subtitle":null,"description":null,"author":"fang chao","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2016-07-11T09:12:02.000Z","updated":"2016-07-11T09:12:04.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Tagcloud","date":"2016-07-11T11:07:27.000Z","updated":"2016-07-11T11:08:22.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2016-07-11T11:24:01.000Z","updated":"2016-07-11T11:25:02.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Markdown 简介及进阶","slug":"Markdown-简介及进阶","date":"2017-05-05T13:58:32.000Z","updated":"2017-05-06T02:14:52.523Z","comments":true,"path":"2017/05/05/Markdown-简介及进阶/","link":"","permalink":"http://yoursite.com/2017/05/05/Markdown-简介及进阶/","excerpt":"Markdown简介","text":"Markdown简介 Markdown 简介及进阶[TOC] Markdown简介Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性^0。 本文所用Markdown 语法基于GitHub Flavored Markdown 。 Markdown语法标题 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 示例： 也可以加=====和-----来生成标题。 123456这是一个一级标题==============这是一个二级标题---------------- 字体1234567使用**粗体**表示粗体使用*斜体*表示斜体使用***加粗斜体***表示加粗斜体使用~~删除线~~表示删除线 示例： 粗体 斜体 加粗斜体 删除线 列表 无序列表 使用+ * -表示无序列表 示例： 123- Unordered list1- Unordered list2- Unordered list3 Unordered list1 Unordered list2 Unordered list3 有序列表 使用数字和点生成生成有序列表 1231. Ordered list12. Ordered list23. Ordered list3 Ordered list1 Ordered list2 Ordered list3 链接 行内链接 文字链接 使用[描述](链接地址)为文字加外链接。 示例： 这是B站的官网。 图片链接使用![描述](链接地址)添加图片. 注：图片最好还是存到云上,比如放到Github上,然后用其链接作图片地址. 自动链接 1&lt;http://www.baidu.com/&gt; http://www.baidu.com/ 引用链接 1234上面的图片是我从[视觉中国][1]中找的素材，我想把它存到[Github][2]上。[1]:https://www.vcg.com \"vcg\"[2]:https://github.com \"Github\" 上面的图片是我从视觉中国中找的素材，我想把它存到Github上。 文字引用使用&gt;表示文字引用 示例： 苟利国家生死以，岂因祸福避趋之。 代码块 行内代码块 使用`` 表示行内代码 示例： print(&quot;hello,world&quot;) 加强的代码块 123​```编程语言类型(python/java/.....) code​ 12345678示例：```c++/**​```c++ code​ **/#include using namespace std;int main(){ cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl; return 0; } 123456789101112131415### 表格```markdown| Item | Value | Qty || :--------- | -------: | :--: || 短线分隔了表头和表身 | | || :在左边表示此列左对齐| :在右边表示此列右对齐 | 两边都有冒号表示此列居中 || Phone | 12 USD | 12 || Pipe | 1 USD | 234 | Item Value Qty 短线分隔了表头和表身 :在左边表示此列左对齐 :在右边表示此列右对齐 两边都有:表示此列居中 Phone 12 USD 12 Pipe 1 USD 234 注脚1234567使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Typora[^Le] 编辑器进行书写。[^1]:Markdown是一种纯文本标记语言[^2]:HyperText Markup Language 超文本标记语言[^Le]:免费Markdown编辑软件. 使用 Markdown^1可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Typora^Le 编辑器进行书写。 [^2]: HyperText Markup Language 超文本标记语言 注： 脚注自动被搬运到最后面，请到文章末尾查看，并且脚注后方的链接可以直接跳转回到加注的地方。 目录在想生成目录的地方输入[TOC] LaTex 公式基础行中公式$ 数学公式$ 示例： 质能守恒方式为：$E = mc^2$ 质能守恒方式为：$E = mc^2$ 独立公式$$ 数学公式 $$ 示例： 这是一个不在行内的公式:$$\\sum_{i=1}^n a_i=0$$ 这是一个在行内的公式:$\\sum_{i=1}^n a_i=0$ 这是一个不在行中的公式： $$\\sum_{i=1}^n a_i=0$$ 自动编号的公式1234\\begin&#123;equation&#125;数学公式\\label&#123;eq:当前公式名&#125;\\end&#123;equation&#125; 1234\\begin&#123;equation&#125;x = \\int _&#123;x&#125; ^\\infty \\frac &#123;x&#125;&#123;x+1&#125;\\label&#123;eq:examp&#125;\\end&#123;equation&#125; $$\\begin{equation}x = \\int _{x} ^\\infty \\frac {x}{x+1}\\label{eq:1}\\end{equation}$$ 空格有四种宽度的空格可以使用： \\,、\\;、\\quad 和 \\qquad 。 1$$ a \\, b \\mid a \\; b \\mid a \\quad b \\mid a \\qquad b $$ $$a \\, b \\mid a \\; b \\mid a \\quad b \\mid a \\qquad b$$ 希腊字母 名称 大写 Tex 小写 Tex alpha AA A αα \\alpha beta BB B ββ \\beta gamma ΓΓ \\Gamma γγ \\gamma delta ΔΔ \\Delta δδ \\delta epsilon EE E ϵϵ \\epsilon zeta ZZ Z ζζ \\zeta eta HH H ηη \\eta theta ΘΘ \\Theta θθ \\theta iota II I ιι \\iota kappa KK K κκ \\kappa lambda ΛΛ \\Lambda λλ \\lambda mu MM M μμ \\mu nu NN N νν \\nu xi ΞΞ \\Xi ξξ \\xi omicron OO O οο \\omicron pi ΠΠ \\Pi ππ \\pi rho PP P ρρ \\rho sigma ΣΣ \\Sigma σσ \\sigma tau TT T ττ \\tau upsilon ΥΥ \\Upsilon υυ \\upsilon phi ΦΦ \\Phi ϕϕ \\phi chi XX X χχ \\chi psi ΨΨ \\Psi ψψ \\psi omega ΩΩ \\Omega ωω \\omega 上标和下标上标和下标分别使用^和_,例如$x_z^y$ ：$$xz^y$$. 但是上下标仅仅对下一个组起作用。一个组即单个字符或者{...}包围起来的内容。如上面的公式，我要得到 $$x{z^y}$$ 这个公式就必须用括号$x_{z^y}$。对于单个字符也要用括号，要得到公式 $$x^{10}$$ ,就必须带大括号$x^{10}$，否则$x^10$：$$x^10$$，那就贻笑大方了。 括号 小括号和方括号：() [] 大括号：大括号用来分组，因此要用\\{和\\}表示大括号,也可以用\\lbrace和\\rbrace。如$x = \\{1,2,3,4,...n\\}$ ： $$x = {1,2,3,4,…n}$$ 使用\\langle 和\\rangle表示左，右尖括号。$\\langle$ $\\rangle$ 上取整 \\lceil x \\rceil ： $$\\lceil x \\rceil$$ 下取整\\lfloor x \\rfloor ：$$\\lfloor x \\rfloor$$ 显示大号的括号或分隔符时，用\\left和\\right命令。 示例： $$f(x,y,z) = x^2 + x^y \\left(3+\\frac{7x+5}{1+y^z} \\right)$$ ​$$f(x,y,z) = x^2 + x^y \\left( 3+\\frac{7x+5}{1+y^z} \\right)$$​​ 累加，累乘，交集，并集\\sum_{下标表达式}^{上标表达式}{累加表达式}和\\prod \\bigcup \\bigcap 用来表示累加，累乘，病机，交集。 示例： $$\\sum_1^n {i^2}$$：$$\\sum_1^n{i^2}$$ $$\\prod_{i=0}^n \\frac 1 a $$：$$\\prod_{i=0}^n \\frac 1 a$$ $$\\bigcup _i \\infty n$$ ：$$\\bigcup _i^\\infty n$$ $$\\bigccp _i \\infty n$$ ：$$\\bigcap _i^\\infty n$$ 极限和积分符号\\int用来表示积分符号，同样地，其上下标表示积分的上下限。如，$\\int_1^\\infty dx$：$$\\int_1^\\infty dx$$。 与此类似的符号还有\\iint：$$\\iint$$ ，\\iiint ：$$\\iiint$$ 分式和根式 分式 $\\frac 1 3$ ： $$\\frac 1 3$$ $\\frac {1+x^2}{1-x^3}$ ： $$\\frac {1+x^2}{1-x^3}$$ $a+b\\over c+d$： ：$$a+b\\over c+d$$ 根式 $\\sqrt[3]{x^2\\overy}$ ：$$\\sqrt[3]{x^2\\over y}$$ 省略号\\ldots表示与文本线对齐的省略号，\\cdots表示与文本中线对齐的省略号。 示例： $f(x_1,x_2,x_3,\\ldots,x_n) = x_1^2 + x_2^2 + x_3^2 + \\cdots + x_n^2$ $$f(x_1,x_2,x_3,\\ldots,x_n) = x_1^2 + x_2^2 + x_3^2 + \\cdots + x_n^2$$ 矢量符号\\vec 示例： $\\vec{a} \\cdot \\vec{b} = 0$ $$\\vec{a} \\cdot \\vec{b} = 0$$ 其他特使字符关系运算符 输入 显示 输入 显示 输入 显示 输入 显示 \\pm $\\pm$ \\times $\\times$ \\div $\\div$ \\mid $\\mid$ \\nmid $\\nmid$ \\cdot $\\cdot$ \\circ $\\circ$ \\ast $\\ast$ \\bigodot $\\bigodot$ \\bigotimes $\\bigotimes$ \\bigoplus $\\bigoplus$ \\leq $\\leq$ \\geq $\\geq$ \\neq $\\neq$ \\approx $\\approx$ \\equiv $\\equiv$ \\sum $\\sum$ \\prod $\\prod$ \\coprod $\\coprod$ \\backslash $\\backslash$ 集合运算符 输入 显示 输入 显示 输入 显示 \\emptyset $\\emptyset$ \\in $\\in$ \\notin $\\notin$ \\subset $\\subset$ \\supset $\\supset$ \\subseteq $\\subseteq$ \\supseteq $\\supseteq$ \\bigcap $\\bigcap$ \\bigcup $\\bigcup$ \\bigvee $\\bigvee$ \\bigwedge $\\bigwedge$ \\biguplus $\\biguplus$ 对数运算符 输入 显示 输入 显示 输入 显示 \\log $\\log$ \\lg $\\lg$ \\ln $\\ln$ 三角运算符 输入 显示 输入 显示 输入 显示 30^\\circ $30^\\circ$ \\bot $\\bot$ \\angle A $\\angle A$ \\sin $\\sin$ \\cos $\\cos$ \\tan $\\tan$ \\csc $\\csc$ \\sec $\\sec$ \\cot $\\cot$ 微积分运算符 输入 显示 输入 显示 输入 显示 \\int $\\int$ \\iint $\\iint$ \\iiint $\\iiint$ \\iiiint $\\iiiint$ \\oint $\\oint$ \\prime $\\prime$ \\lim $\\lim$ \\infty $\\infty$ \\nabla $\\nabla$ 逻辑运算符 输入 显示 输入 显示 输入 显示 \\because $\\because$ \\therefore $\\therefore$ \\forall $\\forall$ \\exists $\\exists$ \\not\\subset $\\not\\subset$ \\not&lt; $\\not&lt;$ \\not&gt; $\\not&gt;$ \\not= $\\not=$ 戴帽符号 输入 显示 输入 显示 \\hat{xy} $\\hat{xy}$ \\widehat{xyz} $\\widehat{xyz}$ \\tilde{xy} $\\tilde{xy}$ \\widetilde{xyz} $\\widetilde{xyz}$ \\check{x} $\\check{x}$ \\breve{y} $\\breve{y}$ \\grave{x} $\\grave{x}$ \\acute{y} $\\acute{y}$ 连线符号 输入 显示 \\fbox{a+b+c+d} $\\fbox{a+b+c+d}$ \\overleftarrow{a+b+c+d} $\\overleftarrow{a+b+c+d}$ \\overrightarrow{a+b+c+d} $\\overrightarrow{a+b+c+d}$ \\overleftrightarrow{a+b+c+d} $\\overleftrightarrow{a+b+c+d}$ \\underleftarrow{a+b+c+d} $\\underleftarrow{a+b+c+d}$ \\underrightarrow{a+b+c+d} $\\underrightarrow{a+b+c+d}$ \\underleftrightarrow{a+b+c+d} $\\underleftrightarrow{a+b+c+d}$ \\overline{a+b+c+d} $\\overline{a+b+c+d}$ \\underline{a+b+c+d} $\\underline{a+b+c+d}$ \\overbrace{a+b+c+d}^{Sample} $\\overbrace{a+b+c+d}^{Sample}$ \\underbrace{a+b+c+d}_{Sample} $\\underbrace{a+b+c+d}_{Sample}$ \\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0} $\\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0}$ \\underbrace{a\\cdot a\\cdots a}_{b\\text{ times}} $\\underbrace{a\\cdot a\\cdots a}_{b\\text{ times}}$ 箭头符号 推荐使用符号： 输入 显示 输入 显示 输入 显示 \\to $\\to$ \\mapsto $\\mapsto$ \\implies $\\implies$ \\iff $\\iff$ \\impliedby $\\impliedby$ 其它可用符号： 输入 显示 输入 显示 \\uparrow $\\uparrow$ \\Uparrow $\\Uparrow$ \\downarrow $\\downarrow$ \\Downarrow $\\Downarrow$ \\leftarrow $ \\leftarrow$ \\Leftarrow $\\Leftarrow$ \\rightarrow $\\rightarrow$ \\Rightarrow $\\Rightarrow$ \\leftrightarrow $\\leftrightarrow$ \\Leftrightarrow $\\Leftrightarrow$ \\longleftarrow $\\longleftarrow$ \\Longleftarrow $\\Longleftarrow$ \\longrightarrow $\\longrightarrow$ \\Longrightarrow $\\Longrightarrow$ \\longleftrightarrow $\\longleftrightarrow$ \\Longleftrightarrow $\\Longleftrightarrow$ 高级如何进行字体转换若要对公式的某一部分字符进行字体转换，可以用 {\\字体 {需转换的部分字符}} 命令，其中 \\字体 部分可以参照下表选择合适的字体。一般情况下，公式默认为意大利体 。 示例中 全部大写 的字体仅大写可用。 输入 说明 显示 输入 说明 显示 \\rm 罗马体 $\\large\\rm {sample}$ \\cal 花体 $\\large\\cal {sample}$ \\it 意大利体 $\\large\\it {sample}$ \\Bbb 黑板粗体 $\\large\\Bbb {sample}$ \\bf 粗体 $\\large \\bf{sample}$ \\mit 数学斜体 $\\large \\mit {sample}$ \\sf 等线体 $\\large \\sf {sample}$ \\scr 手写体 $\\large \\scr{sample}$ \\tt 打字机体 $\\large \\tt {sample}$ \\frak 旧德式字体 $\\large \\frak{sample}$ 转换字体十分常用，例如在积分中： 例子： 12345\\begin&#123;array&#125;&#123;cc&#125;\\mathrm&#123;Bad&#125; &amp; \\mathrm&#123;Better&#125; \\\\\\hline \\\\\\int_0^1 x^2 dx &amp; \\int_0^1 x^2 \\,&#123;\\rm d&#125;x\\end&#123;array&#125; 显示：$$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\hline \\\\int_0^1 x^2 dx &amp; \\int_0^1 x^2 \\,{\\rm d}x\\end{array}$$ 注意比较两个式子间$dx$ 与 ${\\rm d}x$ 的不同。使用 \\operatorname 命令也可以达到相同的效果，详见 定义新的符号 \\operatorname 。 大括号使用 \\left 和 \\right 来创建自动匹配高度的 (圆括号)，[方括号] 和 {花括号} 。在每个公式末尾前使用 \\tag{行标} 来实现行标。 123456789$$F^&#123;HLLC&#125;=\\left\\&#123;\\begin&#123;array&#125;&#123;rl&#125;F_L &amp; &amp; &#123;0 &lt; S_L&#125;\\\\F^*_L &amp; &amp; &#123;S_L \\leq 0 &lt; S_M&#125;\\\\F^*_R &amp; &amp; &#123;S_M \\leq 0 &lt; S_R&#125;\\\\F_R &amp; &amp; &#123;S_R \\leq 0&#125;\\end&#123;array&#125; \\right.$$ $$F^{HLLC}=\\left{\\begin{array}{rl}F_L &amp; &amp; {0 &lt; S_L}\\F^_L &amp; &amp; {S_L \\leq 0 &lt; S_M} \\F^_R &amp; &amp; {S_M \\leq 0 &lt; S_R}\\F_R &amp; &amp; {S_R \\leq 0}\\end{array} \\right.$$ 表格使用$$\\begin{array}{列样式}…\\end{array}$$这样的形式来创建表格，列样式可以是c l r表示居中，左，右对齐，还可以使用|表示一条竖线。表格中 各行使用\\\\分隔，各列使用&amp;分隔。使用\\hline在本行前加入一条直线。 示例： 123456789$$\\begin&#123;array&#125;&#123;c|lcr&#125;n &amp; \\text&#123;Left&#125; &amp; \\text&#123;Center&#125; &amp; \\text&#123;Right&#125; \\\\\\hline1 &amp; 0.24 &amp; 1 &amp; 125 \\\\2 &amp; -1 &amp; 189 &amp; -8 \\\\3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\\\end&#123;array&#125;$$ $$\\large\\begin{array}{c|clr}n &amp; \\text{Left} &amp; \\text{Center} &amp; \\text{Right} \\\\hline1 &amp; 0.24 &amp; 1 &amp; 125 \\2 &amp; -1 &amp; 189 &amp; -8 \\3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\end{array}$$ 方程组使用 \\begin{array}…\\end{array} 和 \\left\\{…\\right. 来创建一个方程组。 123456789$$\\left\\&#123;\\begin&#123;array&#125;&#123;l&#125;x + y + z = 1 \\\\x^2 + z =2 \\\\y*z = 10 \\\\\\end&#123;array&#125;\\right.$$ $$\\large\\left{\\begin{array}{l}x + y + z = 1 \\x^2 + z =2 \\y*z = 10 \\\\end{array}\\right.$$ 使用条件表达式组 \\begin{cases}…\\end{cases} 更方便： 1234567$$\\begin&#123;cases&#125;a_1x+b_1y+c_1z=d_1 \\\\a_2x+b_2y+c_2z=d_2 \\\\a_3x+b_3y+c_3z=d_3\\end&#123;cases&#125;$$ $$\\large\\begin{cases}a_1x+b_1y+c_1z=d_1 \\a_2x+b_2y+c_2z=d_2 \\a_3x+b_3y+c_3z=d_3\\end{cases}$$ 矩阵无框矩阵在开头使用 begin{matrix}，在结尾使用 end{matrix}，在中间插入矩阵元素，每个元素之间插入 &amp; ，并在每行结尾处使用 \\\\ 。使用矩阵时必须声明 $ 或 $$ 符号。 1234567$$ \\begin&#123;matrix&#125; 1 &amp; x &amp; x^2 \\\\ 1 &amp; y &amp; y^2 \\\\ 1 &amp; z &amp; z^2 \\\\ \\end&#123;matrix&#125;$$ $$ \\begin{matrix} 1 &amp; x &amp; x^2 \\ 1 &amp; y &amp; y^2 \\ 1 &amp; z &amp; z^2 \\ \\end{matrix}$$ 边框矩阵在开头将 matrix 替换为 pmatrix bmatrix Bmatrix vmatrix Vmatrix 。 123456$ \\begin&#123;matrix&#125; 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end&#123;matrix&#125; $$ \\begin&#123;pmatrix&#125; 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end&#123;pmatrix&#125; $$ \\begin&#123;bmatrix&#125; 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end&#123;bmatrix&#125; $$ \\begin&#123;Bmatrix&#125; 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end&#123;Bmatrix&#125; $$ \\begin&#123;vmatrix&#125; 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end&#123;vmatrix&#125; $$ \\begin&#123;Vmatrix&#125; 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end&#123;Vmatrix&#125; $ $$\\begin{matrix} 1 &amp; 2 \\ 3 &amp; 4 \\ \\end{matrix}\\begin{pmatrix} 1 &amp; 2 \\ 3 &amp; 4 \\ \\end{pmatrix} \\begin{bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \\ \\end{bmatrix} \\begin{Bmatrix} 1 &amp; 2 \\ 3 &amp; 4 \\ \\end{Bmatrix} \\begin{vmatrix} 1 &amp; 2 \\ 3 &amp; 4 \\ \\end{vmatrix} \\begin{Vmatrix} 1 &amp; 2 \\ 3 &amp; 4 \\ \\end{Vmatrix}$$ 带省略符号的矩阵使用 \\cdots $\\cdots$ , \\ddots $\\ddots$ , \\vdots $\\vdots$ 来输入省略符号。 12345678$$ \\begin&#123;pmatrix&#125; 1 &amp; a_1 &amp; a_1^2 &amp; \\cdots &amp; a_1^n \\\\ 1 &amp; a_2 &amp; a_2^2 &amp; \\cdots &amp; a_2^n \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; a_m &amp; a_m^2 &amp; \\cdots &amp; a_m^n \\\\ \\end&#123;pmatrix&#125;$$ $$\\begin{pmatrix} 1 &amp; a_1 &amp; a_1^2 &amp; \\cdots &amp; a_1^n \\ 1 &amp; a_2 &amp; a_2^2 &amp; \\cdots &amp; a_2^n \\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ 1 &amp; a_m &amp; a_m^2 &amp; \\cdots &amp; a_m^n \\ \\end{pmatrix}$$ 增广矩阵12345678$$\\left[ \\begin&#123;array&#125;&#123;cc|c&#125; 1&amp;2&amp;3\\\\ 4&amp;5&amp;6 \\end&#123;array&#125;\\right]$$ $$\\left[ \\begin{array}{cc|c} 1&amp;2&amp;3\\ 4&amp;5&amp;6 \\end{array}\\right]$$ 分类表达式定义函数的时候经常需要分情况给出表达式，可使用\\begin{cases}…\\end{cases}。其中，使用\\来分类，使用&amp;指示需要对齐的位置。如： 1234567$$f(n) =\\begin&#123;cases&#125;n &amp;\\text&#123;if $n$ is even&#125;\\\\3n+1, &amp; \\text&#123;if $n$ is odd&#125;\\\\\\end&#123;cases&#125;$$ $$f(n) =\\begin{cases}n &amp;\\text{if $n$ is even}\\3n+1, &amp; \\text{if $n$ is odd}\\ \\end{cases}$$ 123456789$$ \\left. \\begin&#123;array&#125;&#123;l&#125; \\text&#123;if $n$ is even:&#125;&amp; \\frac n 2 \\\\ \\text&#123;if $n$ is odd:&#125;&amp;3n+1 \\end&#123;array&#125; \\right\\&#125; =f(n)$$ $$\\left. \\begin{array}{l} \\text{if $n$ is even:}&amp; \\frac n 2 \\[3ex] \\text{if $n$ is odd:}&amp;3n+1 \\[2ex] \\end{array} \\right} =f(n)$$ 流程图12345678910st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考 序列图语法参考 甘特图语法参考 Mermaid 序列图语法参考 Markdown编译器 atom Typora Cmd Markdown","categories":[],"tags":[]},{"title":"C#底层执行模型-CLR","slug":"C-底层执行模型-CLR","date":"2016-11-27T08:05:59.000Z","updated":"2016-11-27T08:05:59.405Z","comments":true,"path":"2016/11/27/C-底层执行模型-CLR/","link":"","permalink":"http://yoursite.com/2016/11/27/C-底层执行模型-CLR/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Java-类","slug":"Java-类","date":"2016-10-02T08:20:31.000Z","updated":"2016-10-02T08:20:32.000Z","comments":true,"path":"2016/10/02/Java-类/","link":"","permalink":"http://yoursite.com/2016/10/02/Java-类/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Java基本程序结构","slug":"Java基本程序结构","date":"2016-09-18T14:05:20.000Z","updated":"2016-09-22T15:54:34.000Z","comments":true,"path":"2016/09/18/Java基本程序结构/","link":"","permalink":"http://yoursite.com/2016/09/18/Java基本程序结构/","excerpt":"Java的基本语法（与C/C++相对比）","text":"Java的基本语法（与C/C++相对比） 注释 1234567/** * 文档注释 */ //单行注释 /*长篇注释 */ 数据类型 Java没有任何无符号类型 整形java的整型范围与所在的机器无关 |类型 |存储需求 | 取值范围||——–|———|———||int | 4字节 |-2147483648~2147483647||short | 2字节 |-32768~32767||long |8字节 | ||byte| 1字节 |-128~127| 长整型有后缀L 二进制的前缀0b 浮点类型|类型|存储需求||—-|—-||float|4字节||double|8字节| float类型后加f,默认为’double’. 浮点数的计算遵循IEEE754规则（参考csapp第一章）。 特殊浮点数： 正无穷大 负无穷大 NaN 一个正整数除以0的结果为正无穷大。计算0/0或者负数的平方根结果为NaN。 char类型Java中,char类型用UTF-16编码描述一个代码单元。 强烈建议不要在程序中使用char类型，最好将需要处理的字符串用抽象数据类型表示 boolean类型java中整数不能转换为布尔值。 12if(x=0)//不能通过编译 System.out.println(\"oo-oo\")l; 变量java中声明一个变量之后，必须用赋值语句对变量进行显式初始化，千万不能使用未使用初始化的变量。java中不区分变量的额定义和声明。 final指示常量。 ++,--运算符解析 在c/c++中123&gt; int i=0,j=0;&gt; j=++i+++i+i++；&gt; 这种代码常见于各类“谭书”中，经常出现在各种新手论坛中或某计算机考试中，这样的问题实在是不应该浪费时间，因为它们几乎都是“未指明的行为”或“由实现定义的行为”。另一方面，程序的错误或Bugs，通常是由于“未定义的行为”。使用了未定义行为的程序都是错误的，即使程序能够运行，也只是巧合。未定义行为源于编译器不能检测到的程序错误或太麻烦以至无法检测的错误。不幸的是，含有未定义行为的程序在有些环境或编译器中可以正确执行，但并不能保证同一程序在不同编译器中甚至在当前编译器的后继版本中会继续正确运行，也不能保证程序在一组输入上可以正确运行且在另一组输入上也能正确运行。 程序不应该依赖未定义行为。 在Java中 数值转换 两个操作数有一个是double，另一个也会转换为double。 否则，其中一个是float，另一个也将转换为flaot。 否则，其中一个是long，另一个也将转换为long。 否则，两个都将转换为int。 字符串java字符串就是Unicode字符序列。 子串使用substring方法可以从一个大的字符串中提取一个子串。 12String greeting = \"hello\";String s = greeting.substring(0,3);//s=hel 拼接java使用+拼接字符串。(任何一个java对象都可以转化为字符串) 不可变字符串String类没有提供可以修改字符串的方法。但是java可以用重新创建字符串的方法进行修改。 12String str = \"hello\";str = str.substring(0,3)+\"p!\";//str=\"help!\" 在Java切忌认为String是字符数组，事实上，java的String更像是char*指针。 12345char* str = \"hello\";char* temp = malloc(6);//字符串末尾还有'\\0'strncpy(temp,str,3);strnpy(temp+3,\"p!\",3);str = temp; 检测字符串相等s.equals(t); 不区分大小写的是equalsIgnoreCase. ==只能比较字符串是否在同一个内存中。 &quot;&quot;是长度为0的字符串 代码点和代码单元java字符串由char序列组成，char数据类型是一个采用UTF-16编码表示Unicode代码点的代码单元。 而大多数的常用Unicode字符使用一个代码单元就可以表示，而辅助字符却需要两个。 学过《深入理解计算机系统》（csapp）这些问题都是很简单的。 字符是抽象的最小文本单位。它没有固定的形状（可能是一个字形），而且没有值。“A”是一个字符，“€”（德国、法国和许多其他欧洲国家通用货币的标志）也是一个字符。 字符集是字符的集合。例如，汉字字符是中国人最先发明的字符，在中文、日文、韩文和越南文的书写中使用。 编码字符集是一个字符集，它为每一个字符分配一个唯一数字。Unicode 标准的核心是一个编码字符集，字母“A”的编码为 004116 和字符“€”的编码为20AC16.Unicode 标准始终使用十六进制数字，而且在书写时在前面加上前缀“U+”，所以“A”的编码书写为“U+0041”。 代码点是指可用于编码字符集的数字。编码字符集定义一个有效的代码点范围，但是并不一定将字符分配给所有这些代码点。有效的 Unicode 代码点范围是 U+0000 至 U+10FFFF.Unicode 4.0 将字符分配给一百多万个代码点中的 96，382 代码点。 增补字符是代码点在 U+10000 至 U+10FFFF 范围之间的字符，也就是那些使用原始的 Unicode 的 16 位设计无法表示的字符。从 U+0000 至 U+FFFF 之间的字符集有时候被称为基本多语言面 （BMP）。因此，每一个 Unicode 字符要么属于 BMP，要么属于增补字符。 字符编码方案是从一个或多个编码字符集到一个或多个固定宽度代码单元序列的映射。最常用的代码单元是字节，但是 16 位或 32 位整数也可用于内部处理。UTF-32、UTF-16 和 UTF-8 是 Unicode 标准的编码字符集的字符编码方案。 UTF-32 即将每一个 Unicode 代码点表示为相同值的 32 位整数。很明显，它是内部处理最方便的表达方式，但是，如果作为一般字符串表达方式，则要消耗更多的内存。 UTF-16 使用一个或两个未分配的 16 位代码单元的序列对 Unicode 代码点进行编码。值 U+0000 至 U+FFFF 编码为一个相同值的 16 位单元。增补字符编码为两个代码单元，第一个单元来自于高代理范围（U+D800 至 U+DBFF），第二个单元来自于低代理范围（U+DC00 至 U+DFFF）。这在概念上可能看起来类似于多字节编码，但是其中有一个重要区别：值 U+D800 至 U+DFFF 保留用于 UTF-16；没有这些值分配字符作为代码点。这意味着，对于一个字符串中的每个单独的代码单元，软件可以识别是否该代码单元表示某个单单元字符，或者是 否该代码单元是某个双单元字符的第一个或第二单元。这相当于某些传统的多字节字符编码来说是一个显著的改进，在传统的多字节字符编码中，字节值 0x41 既可能表示字母“A”，也可能是一个双字节字符的第二个字节。 UTF-8 使用一至四个字节的序列对编码 Unicode 代码点进行编码。U+0000 至 U+007F 使用一个字节编码，U+0080 至 U+07FF 使用两个字节，U+0800 至 U+FFFF 使用三个字节，而 U+10000 至 U+10FFFF 使用四个字节。UTF-8 设计原理为：字节值 0x00 至 0x7F 始终表示代码点 U+0000 至 U+007F（Basic Latin 字符子集，它对应 ASCII 字符集）。这些字节值永远不会表示其他代码点，这一特性使 UTF-8 可以很方便地在软件中将特殊的含义赋予某些 ASCII 字符。 | Unicode代码点 | U+0041| U+00DF| U+6771| U+10400|————–|———|—-|——-|—–||表示字形 ||UTF-32代码单元|00000041|000000DF|00006771|00010400||UTF-16代码单元|0041|00DF|6771|D801 DC00||UTF-8代码单元|41|C3 9F|E6 9D B1|F0 90 90 80| length方法得到的是采用UTF-16编码表示的给定字符串所需要的代码单元数量。 12String greeting = \"hello\";int n = greeting.length();//5 而要得到实际的长度，即代码点数量，需要调用： 1int cpCount = greeting.codePointCount(0,greeting.length())` ####构建字符串 在前面采用的连接重建字符串的方法是非常慢，这一点不罗曼缇克。使用StringBuilder就好了。 StringBuilder builder = new StringBuilder() 添加时用append，构建新的时候用toString就好。 这部分面试的时候会经常问，所以后面会在构造器深入记录。 输入输出 读取输入1234Scanner in = new Scanner(System.in);String name = in.nextLine();//读取一行String word = in.next();//读取一个单词String number = in.nextInt();//读取一个int数 格式化输出与c基本相同 文件输入输出读取文件要构造一个Scanner对象。 Scanner in = new Scanner(Paths.get(&quot;&quot;)) 写入文件要构造PrintWrite对象。 PrintWrite in = new PrintWrite(&quot;&quot;) 控制流程与c相同，多了for each 数组创建数组： 12int[] a = new int[100];String[] a = new String[100]; 创建一个数字数组时，所有元素初始化为0；创建一个boolean数组时，所有对象初始化为false;创建一个对象数组，则所有元素会被初始化为null。 for each格式： for (variable : collection) statement 表示为每一个变量是暂存于集合中的变量，这个集合表达式必须是一个数组或者实现了Iterable的接口。 数组初始化123int[] ArrayInt = &#123;1,2,3,5&#125;；//创建数组对象并同时初始化OtherArrayInt = new int[] &#123;1,2,3,5&#125;//相当于int[] ArrayInt = &#123;1,2,3,5&#125;；OtherArrayInt=ArrayInt；new elementType[0];//创建一个长度为0的数组 多维数组12345int[][] Array = &#123; &#123;1,2&#125;, &#123;1,24&#125;, &#123;7,8,&#125;&#125; 不规则数组12345678910111213int NMAX = 10;int[][] odds = new int [NMAX+1][];for(int n = 0;n&lt;= NMAX;n++) odds[n] = new int[n+1];for(int n =0;n&lt;odds.length;n++) for(int k = 0; k&lt;odds[n].length;k++) &#123; int lotteryOdds = 1; for(int i =1;i&lt;=k;i++) lotteryOdds = lotteryOdds*(n-i+1)/i; odds[n][k] = lotteryOdds; &#125; //compute n*(n-1)*(n-2)*...*(n-k+1)/(1*2*3*...*k)","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"JavaScript-ECMAScript(基础)","slug":"JavaScript-ECMAScript","date":"2016-08-16T10:55:28.000Z","updated":"2016-08-18T00:38:08.000Z","comments":true,"path":"2016/08/16/JavaScript-ECMAScript/","link":"","permalink":"http://yoursite.com/2016/08/16/JavaScript-ECMAScript/","excerpt":"对javascript中的基础做一些总结，使用版本为ECMAScript 3.1.","text":"对javascript中的基础做一些总结，使用版本为ECMAScript 3.1. JavaScript在HTML中使用 内部嵌入 1&lt;script type=\"text/javascript&gt;&lt;/script&gt; 外部嵌入 1&lt;script src=\"example.js\"&gt;&lt;/script&gt; 注意： 第二个js脚本可能在第一个脚本之后进行覆盖，所以要确保不会发生冲突。 在内部嵌入的js脚本要写在&lt;body&gt;&lt;/body&gt;的末尾，为了在加载js时不影响阅读。 JavaScript基本语法标识符js的ECMAScript是区分大小写，其标识符由字母、数字、下划线、$构成，标识符的第一个字母不能为数字。 注释注释和C一样，分单行和多行。 数据类型 typeof undefined 使用var但没有对其初始化的变量的类型。 Null Boolean Number 使用的是IEEE754格式 浮点数 数值范围 ECMAScript的最小数值为5e-324，最大则是1.79769313448623157e+308。 超过范围的数会被转换为Infinity和-Infinity. NaN 这是一个特殊的值，表示一个本来要返回数值的操作数未返回数值的情况。涉及到NaN的操作都会返回NaN。 1234alert(NaN == NaN); //falsealert(0/0); //NaMalert(1/0); //Infinityalert(-1/0); //-Infinity 数值转换 转换字符串 parseInt()-忽略前面的空格，直至找到第一个非空格字符，如果第一个字符不是数字字符或者负号，就会返回NaN。 1234var num1 = parseInt（\"1234blue\"); //1234bluevar num2 = parseInt(\"\"); //NaNvar num3 = parseInt(\"0xA\"); //10var num4 = parseInt(\"22.5\"); //22 为了消除parseInt的一些影响，为其添加第二个参数。 12345var num1 = parseInt(\"AF\",16) //175var num2 = parseInt(\"AF\"); //NaNvar num3 = parseInt(\"10\",2); //2（按照二进制）var num3 = parseInt(\"10\",8); //8var num3 = parseInt(\"10\",10); //10 String js里面的单双引号的作用是相同的。 Object 操作符 ==操作符 如果两个操作数相等，返回true，反之false。两个操作符在比较之时会先转换（强制转换），然后再进行比较。 如果有一个操作数是布尔型，则比较的相等性时先将其转换为数值false转换为0，而true转换为1。 如果有一个操作数是字符串，另一个是数值，在比较时先将字符串转换为数值。 如果一个操作数是对象，另一个不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则比较。 null和undefined是相等的。 要比较相等性之前，不能将null和undefined转换为其他值。 如果有一个操作数是NaN，则相等操作符返回false。 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数是同一对象，则返回true，否则false。 ===操作符 在未转换的情况下进行比较。 其余操作符均与C、java相同。 语句 if do-while while for for-in label break,continue with switch 函数 1234function functionName(arg0,arg1,arg2,...,argN)&#123; statements；&#125; 没有重载 在ECMAScript中定义两个相同名字的函数，则该名字只属于后定义的函数。 基本类型ECMAScript变量包含两种不同数据类型的的值：基本类型值和引用类型值。 ECMAScript中所有函数的参数都是按值传递的。很多同学都以为对象不是按值传递： 123456789101112function setName()&#123; obj.name = \"Nichols\"; obj = new Object(); obj.name = \"Greg\";&#125;var person = new Object();setName(person);alert(person.name);//\"Nichols\"/*即使在函数内部改变参数的值，单原始的引用仍然没有变。实际上，当在函数内部重写obj的时候，这个变量引用的已经是一个局部对象了。这个对象会在函数执行完毕之后被销毁。*/ 引用类型-类引用类型的值（对象）是引用类型的实例。在ECMASript中，引用类型是一种数据结构，用于把数据和功能组织到一起。它也常被称作类。 Object创建Object实例有两种方法： 12345678var person = new Object();//第一种方法person.name = \"wangli\";person.age = 18;var person = &#123; name : \"wangli\";//第二种方法 age : 18;&#125; Array创建数组也有两种方法： 12345var colors = new Array();var colors = new Array(\"red\",\"blue\",\"green\");var colors = [\"red\",\"blue\"];var name = []; 数组常用方法 toString 返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。 pop(),push() 队列方法（先进先出） shift(),unshift()在数组第一位进行操作 排序 sort() reverse() concat(),slice(),splice() 12345678910111213141516171819var colors = [\"red\",\"green\",\"blue\"];var color1 = colors.concat(\"yellow\",[\"black\",\"brown\"]);var color2 = colors.slice(1);var color3 = color1.slice(1,3);alert(colors); //red,green,bluealert(color1); //red,green,blue,yellow,black,brownalert(color2); //green,bluealert(color3); //grenn,blue,yellowvar colors = [\"red\",\"green\",\"blue\"];var removed = color.splice(0,1);//删除第一项alert(colors); //green,bluealert(removed); //redremoved = colors.splice(1,0,\"yellow\",\"orange\");//从位置1处插入两项alert(colors);//green,yellow,orange,bluealert(colors);//返回一个空数组removed = colors.splice(1,1,\"red\",\"purple\")//插入两项，删除一项alert(colors); //green,red,purple,orange,bluealert(removed);//yellow,返回的数组中只包含一项 位置方法 indexOf()从数组开头位置查找lastIndexOf()从数组末尾开始向前查找 迭代方法 every对数组的每一项运行指定函数，如果每项都返回true，则返回true。 filter()对数组中每个返回true的项组成数组并返回。 map(),some()都是用来查询数组中的项是否满足某个条件。对于every，传入的函数必须对每一项返回true,才会返回true，否则是false。而some（）则是只要有一项返回true，则返回true。 归并方法reduce(),reduceRight()12345var values = [1,2,3,4,5];var sum = values.reduce(function(prex,cur,index,array)&#123; return prev+cur;&#125;) alert(sum); //15 Date类型RegExp 类型RegExp的每个实例都有下列属性： global: 布尔值，表示是否设置g标志。 ignoreCase： 布尔值，表示是否设置i标志。 lastIndex： 整数，表示开始搜索下一个匹配项的字符位置，从0开始。 multiline： 布尔值，表示是否设置m标志。 source： 正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。 Function 类型函数声明和函数表达式：在解析器中，会先读取函数声明，并使其在执行任何代码前可用；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被执行。123456789alert(sum(10,10));//正常执行function sum(sum1,sum2)&#123; return sum1+sum2;&#125;alert(sum(10,10)); //产生错误var sum = function(num1, num2)&#123; return sum1+sum2;&#125;; 函数内部属性： this 对于javaScript，万物皆对象，而this就执行着当前对象 123456789101112131415function f()&#123; return \"天气：\"+this.weather;&#125;var sunDay&#123; palyer : liming; weather : hot; hh : f&#125;var monDay&#123; palyer : lihua; weather : cool; hh :f&#125;alert(sunDay.hh);//天气：hotalert(monDay.hh);//天气：cool this是非常灵活的，但是有时我们也需要将其固定下来。javascript提供了三个方法apply bind call来固定\\切换this的指向 call 指定this的指向，然后在所指定的作用域，调用其函数。 1234567function sum(sum1,sum2)&#123; return sum1+sum2;&#125; function callSum(num1,num2)&#123; return sum.call(this, num1, num2); &#125; alter(callSum(10,10)); //20 apply apply方法与call相似，只不过传递的是数组。 1234567891011function sum(num1, num2)&#123; return num1+num2;&#125;function callSum1(num1,num2)&#123; return sum.apply(this ,arguments);&#125;function callSum2(num1, num2)&#123; return sum.apply(this , [num1,num2]);&#125;alter(callSum1(10,10)); //20alter(callSum2(10,10)); //20 bind bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。 12345678910111213var add = function (x, y) &#123; return x * this.m + y * this.n;&#125;var obj = &#123; m: 2, n: 2&#125;;var newAdd = add.bind(obj, 5);newAdd(5)// 20 基本包装类型从代码来看123var s1 = \"some text\";var s2 = s1.subString(2);` 在执行上述代码时后台操作是： 创建String类型的一个实例。 在实例上调用指定的方法。 销毁这个实例。操作如同下面的代码：123var s1 = new String(\"some text\");var s2 = s1.subString(2);s1 = null; 引用类型与基本包装类型的区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前一直保存在内存中。而自动创建的基本包装类型对象，则只存在于一行代码的瞬间执行，然后销毁。这意味着我们并不能在运行时为基本类型添加属性和方法。 Boolean类型 不建议使用 Number类型 要创建Number对象，可以调用Number构造函数时向其中传递相应的数值var numberObject = new Number(10); String类型 String类型是字符串的对象包装类型，可以像下面这样使用String构造函数来创建var stringObject = new String(&quot;hello world&quot;); 字符方法 charAt() charCodeAt(),例如： 1234var stringValue = \"hello world\";alert(stringValue.charAt(1)); //\"e\" ,输出的是字符alert(stringValue.charCodeAt(1)); //\"101\" 输出的是字符编码（utf-8）alert(stringValue[1]); //\"e\" 字符串操作方法 conact字符串拼接 slice、substr、substring三种创新字符串的方法 1234567var stringValue = \"hello world\";alert(stringValue.slice(-3));//\"rld\"alert(stringValue.substring(-3);//\"hello world\" 负值会被转化成0alert(stringValue.substr(-3));//\"rld\"alert(stringValue.slice(3,-4));//\"lo w\"alert(stringValue.substring(3,-4));//\"hel\"alert(stringValue.substr(3,-4));//\"\" 字符串位置方法 indexOf、lastIndexOf trim 删除字符串前后的空格 字符串大小写转换方法 字符串模式匹配 localeCompare 12345var stringValue = \"yellow\";alert(stringValue.localeCompare(\"brick\")); //1alert(stringValue.localeCompare(\"yellow\")); //0alert(stringValue.localeCompare(\"zoo\")); //-1 fromCharCode 将字符编码转换为字符串 1alert(String.fromCharCode(104, 101, 108, 108,111)); //\"hello\" eval 12eval(\"alert('hi')\");alert('hi'); //两句完全相同 random 1值 = Math.floor(Math.random()*可能值的总数+第一个可能的值)","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ECMAScript","slug":"ECMAScript","permalink":"http://yoursite.com/tags/ECMAScript/"}]},{"title":"JavaScript学习笔记","slug":"JavaScript学习笔记","date":"2016-08-16T10:41:42.000Z","updated":"2016-08-16T11:44:36.000Z","comments":true,"path":"2016/08/16/JavaScript学习笔记/","link":"","permalink":"http://yoursite.com/2016/08/16/JavaScript学习笔记/","excerpt":"","text":"JavaScript是一种专为网页交互设计的脚本语言。JavaScript由三部分组成： ECMAScript 文档对象模型（DOM） 浏览器对象模型（BOM） js的学习我也分这三部分做笔记。","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Java之旅","slug":"Java之旅","date":"2016-08-11T04:42:22.000Z","updated":"2016-08-11T04:45:06.000Z","comments":true,"path":"2016/08/11/Java之旅/","link":"","permalink":"http://yoursite.com/2016/08/11/Java之旅/","excerpt":"","text":"开始学Java，定期整理学习笔记，就这样吧。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/tags/Java学习/"}]},{"title":"STM32 ADC使用（基础篇）","slug":"STM32 ADC使用（基础篇）","date":"2016-07-11T09:39:14.000Z","updated":"2016-08-18T00:39:40.000Z","comments":true,"path":"2016/07/11/STM32 ADC使用（基础篇）/","link":"","permalink":"http://yoursite.com/2016/07/11/STM32 ADC使用（基础篇）/","excerpt":"STM32上集成的ADC（Analog to Digital Convert）外设很强大。在以前用89C51时，还需要芯片来处理AD/DA,而现在用stm32显然方便很多。","text":"STM32上集成的ADC（Analog to Digital Convert）外设很强大。在以前用89C51时，还需要芯片来处理AD/DA,而现在用stm32显然方便很多。 STM32（F10x系列）有3个12位的ADC，每个ADC有12个通道。各个通道的A/D转换可以单次也可以多次，连续，扫描，间断执行。ADC的结果可以左对齐或者右对齐的方式进行存储在16位的数据寄存器中。模拟看门狗允许应用程序检测电压是否超出规定阈值。 ADC基本配置可以参考《STM32库开发实战指南》,至于在ADC转换的过程中使用注入、中断、看门狗等在进阶篇再介绍，在此只详细记录三种AD转换。 ADC单通道转换。 ADC单通道转换（DMA方式）。 ADC多通道转换（DMA方式）。 ADC单通道转换直接贴代码叙述12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void Adc_Init(void) &#123; ADC_InitTypeDef ADC_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |RCC_APB2Periph_ADC1, ENABLE ); //使能ADC1通道时钟，并使能接受ADC转换的GPIO RCC_ADCCLKConfig(RCC_PCLK2_Div6); //设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M，（可设置的分频系数为2、4、6、8） //PA1 作为模拟通道输入引脚 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; //模拟输入引脚 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); ADC_DeInit(ADC1); //复位ADC1 ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; //ADC工作模式:STM32有多种工作模式，而不同的ADC又是共用通道，当两个ADC采集同一个通道的先后顺序和时间间隔不同，就有不同的方式。具体的各个方式可在手册中查询。 ADC_InitStructure.ADC_ScanConvMode = DISABLE; //模数转换工作在单通道模式。当多通道需要ADC采集时，可把ADC配置为按一定顺序对各个通道进行扫描转换，即进行轮流采集各通道的值。若采集多个通道，则必须开启此模式。 ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; //模数转换工作在单次转换模式。可设置为连续和单次。 ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; //转换由软件而不是外部触发启动 ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; //ADC数据右对齐（ADC的转换精度为12位，而ADC的数据存储器-ADC_DR为16位，所以就有了左对齐和右对齐） ADC_InitStructure.ADC_NbrOfChannel = 1; //顺序进行规则转换的ADC通道的数目（1-16) ADC_Init(ADC1, &amp;ADC_InitStructure); //根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器 ADC_Cmd(ADC1, ENABLE); //使能指定的ADC1 ADC_ResetCalibration(ADC1); //使能复位校准 while(ADC_GetResetCalibrationStatus(ADC1)); //等待复位校准结束 ADC_StartCalibration(ADC1); //开启AD校准 while(ADC_GetCalibrationStatus(ADC1)); //等待校准结束 // ADC_SoftwareStartConvCmd(ADC1, ENABLE); //使能指定的ADC1的软件转换启动功能 &#125; //获得ADC值 //ch:通道值 0~3 ADC_Channel_0(0-17) u16 Get_Adc(u8 ch) &#123; //设置指定ADC的规则组通道，一个序列，采样时间 ADC_RegularChannelConfig(ADC1, ch, 1, ADC_SampleTime_239Cycles5 ); //ADC1,ADC通道,采样时间为239.5周期（T=采样周期+12.5个周期） ADC_SoftwareStartConvCmd(ADC1, ENABLE); //使能指定的ADC1的软件转换启动功能 while(!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC ));//等待转换结束 return ADC_GetConversionValue(ADC1); //返回最近一次ADC1规则组的转换结果 &#125; u16 Get_Adc_Average(u8 ch,u8 times) &#123; u32 temp_val=0; u8 t; for(t=0;t&lt;times;t++) &#123; temp_val+=Get_Adc(ch); delay_ms(5); &#125; return temp_val/times; &#125; 在main函数中只要调用adcx=Get_Adc_Average(ADC_Channel_1,10);之类的就可以读取转换的值。 ADC单通道转换(DMA方式)为什么要用DMA方式在上述的ADC转换中，CPU要处理由ADC外设采集回来的数据时，CPU首先要把数据从ADC外设的寄存器读取到CPU内存中，然后进行运算。但是用CPU来转换数据是有些杀鸡用牛刀，用DMA方式可以大大减轻CPU工作，从而提高运算效率。 贴代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#define ADC1_DR_Address ((u32)0x40012400+0x4c)//DMA传输的外设地址ADC1_DR_Address是一个自定义的宏ADC_DR保存了ADC转换的值，以它作为DMA传输的源地址。__IO uint16_t ADC_ConvertedValue;//在传输地址中定义一个基地址//__IO u16 ADC_ConvertedValueLocal;static void ADC1_GPIO_Config(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; /* 使能DMA时钟 */ RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_GPIOC, ENABLE); /* 输入的GPIO口定义*/ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;//ADC必须为模拟输入（输入后ADC转换为二进制） GPIO_Init(GPIOC, &amp;GPIO_InitStructure); // PC1,输入时不用设置速率&#125;static void ADC1_Mode_Config(void)&#123; DMA_InitTypeDef DMA_InitStructure; ADC_InitTypeDef ADC_InitStructure; /* DMA channel1 configuration */ DMA_DeInit(DMA1_Channel1); DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address; //ADC地址 DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&amp;ADC_ConvertedValue;//内存地址 DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC; DMA_InitStructure.DMA_BufferSize = 1; DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;//外设地址固定 DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable; //内存地址固定 DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord; //半字 DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord; DMA_InitStructure.DMA_Mode = DMA_Mode_Circular; //循环传输 DMA_InitStructure.DMA_Priority = DMA_Priority_High; DMA_InitStructure.DMA_M2M = DMA_M2M_Disable; DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure); /* Enable DMA channel1 */ DMA_Cmd(DMA1_Channel1, ENABLE); /* ADC1 configuration */ ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; //独立ADC模式 ADC_InitStructure.ADC_ScanConvMode = DISABLE ; //禁止扫描模式，扫描模式用于多通道采集 ADC_InitStructure.ADC_ContinuousConvMode = ENABLE; //开启连续转换模式，即不停地进行ADC转换 ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; //不使用外部触发转换 ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; //采集数据右对齐 ADC_InitStructure.ADC_NbrOfChannel = 1; //要转换的通道数目1 ADC_Init(ADC1, &amp;ADC_InitStructure); /*配置ADC时钟，为PCLK2的8分频，即9Hz*/ RCC_ADCCLKConfig(RCC_PCLK2_Div8); /*配置ADC1的通道11为55. 5个采样周期，序列为1 */ ADC_RegularChannelConfig(ADC1, ADC_Channel_11, 1, ADC_SampleTime_55Cycles5); /* Enable ADC1 DMA */ ADC_DMACmd(ADC1, ENABLE); /* Enable ADC1 */ ADC_Cmd(ADC1, ENABLE); /*复位校准寄存器 */ ADC_ResetCalibration(ADC1); /*等待校准寄存器复位完成 */ while(ADC_GetResetCalibrationStatus(ADC1)); /* ADC校准 */ ADC_StartCalibration(ADC1); /* 等待校准完成*/ while(ADC_GetCalibrationStatus(ADC1)); /* 由于没有采用外部触发，所以使用软件触发ADC转换 */ ADC_SoftwareStartConvCmd(ADC1, ENABLE);&#125;void ADC1_Init(void)&#123; ADC1_GPIO_Config(); ADC1_Mode_Config();&#125; 在main函数中读取ADC_ConvertedValue就为转换的到的值（一般来说转换为电压较好ADC_ConvertedValueLocal =(float) ADC_ConvertedValue/4096*3.3;)，记住必须在前面extern下。 ADC多通道转换（ADC多通道转换必须为DMA方式）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 u8 DMA1_MEM_LEN;//DMA1的各通道配置//这里的传输形式是固定的,这点要根据不同的情况来修改//从外设模式-&gt;存储器/16位数据宽度/存储器增量模式 //cmar:存储器地址（自己定义的存储地址AD_DATA[4]） cndtr:数据传输量,实际上就是ADC要转换的路数（N）#define ADC1_DR_Address ((u32)0x40012400+0x4c)//DMA传输的外设地址ADC1_DR_Address是一个自定义的宏ADC_DR保存了ADC转换的值，以它作为DMA传输的源地址。void DMA_Config(u32 cmar,u16 cndtr)&#123; DMA_InitTypeDef DMA_InitStructure; RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); //使能DMA时钟 DMA_DeInit(DMA1_Channel1); //使用DMA的通道1，stm32有两个DMA，每个有7个通道 DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address; //DMA外设基地址 DMA_InitStructure.DMA_MemoryBaseAddr = cmar; //DMA内存基地址 DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC; //数据传输方向，从外设发送到内存 DMA_CCRX位4 DMA_InitStructure.DMA_BufferSize = cndtr; //DMA通道的DMA缓存的大小 DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable; //外设地址寄存器不变 DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; //内存地址寄存器递增 DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord; //外设数据宽度为16位 DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord; //内存数据宽度为16位 DMA_InitStructure.DMA_Mode = DMA_Mode_Circular; //工作在循环缓存模式 DMA_InitStructure.DMA_Priority = DMA_Priority_High; //DMA通道 x拥有高优先级 DMA_InitStructure.DMA_M2M = DMA_M2M_Disable; //DMA通道x没有设置为内存到内存传输 DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure); //根据DMA_InitStruct中指定的参数初始化DMA的通道USART1_Tx_DMA_Channel所标识的寄存器&#125;#define N 4//ADC1的通道数extern u16 AD_DATA[4];void Adc_Init(void)&#123; ADC_InitTypeDef ADC_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |RCC_APB2Periph_ADC1,ENABLE );//使能端口1的时钟和ADC1的时钟，因为ADC1的通道1在PA1上 RCC_ADCCLKConfig(RCC_PCLK2_Div6); //设置ADC分频因子6 72M/6=12M,ADC最大时间不能超过14M，也就是ADC的时钟频率为12MHz //PAx 作为模拟通道输入引脚 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_3|GPIO_Pin_2; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; //模拟输入引脚 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); ADC_DeInit(ADC1); //复位ADC1,将外设 ADC1 的全部寄存器重设为缺省值 ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; //本次实验使用的是ADC1，并ADC1工作在独立模式ADC_CR1的位19:16,即这几位为0000 ADC_InitStructure.ADC_ScanConvMode = ENABLE; //ADC_ScanConvMode 用来设置是否开启扫描模式，本实验开启扫面模式.ADC_CR1的位8 ADC_InitStructure.ADC_ContinuousConvMode = ENABLE; //ADC_ContinuousConvMode 用来设置是否开启连续转换模式 模数转换工作在连续转换模式，ADC_CR2的位1 ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; //转换由软件而不是外部触发启动 ADC_CR2的位19:17 ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; //ADC数据右对齐ADC_CR2的位11 ADC_InitStructure.ADC_NbrOfChannel = N; //顺序进行规则转换的ADC通道的数目ADC_SQR1位23:20 ADC_Init(ADC1, &amp;ADC_InitStructure); //根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器 ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_55Cycles5 );//ADC1；ADC1通道0；第1转换；采样时间为55周期 ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 2, ADC_SampleTime_55Cycles5 );//ADC1；ADC1通道1；第2转换；采样时间为55周期 ADC_RegularChannelConfig(ADC1, ADC_Channel_2, 3, ADC_SampleTime_55Cycles5 ); //ADC1；ADC1通道1；第3转换；采样时间为55周期 ADC_RegularChannelConfig(ADC1, ADC_Channel_3, 4, ADC_SampleTime_55Cycles5 );//ADC1；ADC1通道3；第4转换；采样时间为55周期/**这里的ADC_SampleTime可配置1.5、7.5、13.5、28.5、41.5、55.5、71.5、239.5 其计算公式为T=采样周期+12.5个周期本代码中转换时间T=（55.5+12.5）/12 ----12为ADC时钟配置注意你要输入的进行规则转换的通道数N要全部进行通道配置**/ ADC_DMACmd(ADC1, ENABLE); //使能ADC1的DMA传输，ADC_CR2位8 ADC_Cmd(ADC1, ENABLE); //使能的ADC1,ADC_CR2位0 ADC_ResetCalibration(ADC1); //使能复位校准，ADC_CR2位3 while(ADC_GetResetCalibrationStatus(ADC1)); //等待复位校准结束 ADC_StartCalibration(ADC1); //开启AD校准，ADC_CR2位2 while(ADC_GetCalibrationStatus(ADC1)); //等待校准结束&#125; 在main函数中先声明123#define N 4//ADC1的通道数u16 AD_DATA[N];//AD转换的数字量float value[N];//AD转换的模拟量 然后启动DMA1234Adc_Init();DMA_Config((u32)&amp;AD_DATA,N)DMA_Cmd(DMA1_Channel1, ENABLE);//启动DMA通道ADC_SoftwareStartConvCmd(ADC1, ENABLE);//软件启动AD转换 最后转换为电压即可value[i] =(float) AD_DATA[i]*(3.3/4095)","categories":[{"name":"ARM学习","slug":"ARM学习","permalink":"http://yoursite.com/categories/ARM学习/"}],"tags":[{"name":"stm32","slug":"stm32","permalink":"http://yoursite.com/tags/stm32/"},{"name":"ADC","slug":"ADC","permalink":"http://yoursite.com/tags/ADC/"}]}]}